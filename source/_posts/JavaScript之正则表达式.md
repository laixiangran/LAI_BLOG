---
title: JavaScript之正则表达式
date: 2018-04-08 22:30:32
tags:
- 正则表达式
- JavaScript
categories: JavaScript
---

正则表达式 (regular expression) 描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

## 元字符

![](https://note.youdao.com/yws/api/personal/file/64B961BA598C4A7389E10DF8B7E60227?method=download&shareKey=bde4953f7301f4eedbc29d9e9feb8fb8)

## 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低

![](https://note.youdao.com/yws/api/personal/file/4B6EB93FA452486ABA0EA88EDF8D72BE?method=download&shareKey=c3a31af513efbc05987821e18f495368)

## RegExp对象

### 语法

```javascript
var patt = new RegExp(pattern, modifiers);

// 或者更简单的方式:

var patt = /pattern/modifiers;
```

- pattern（模式） 描述了表达式的模式
- modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配

### 修饰符

修饰符用于执行区分大小写和全局匹配

修饰符 | 描述
--- | ---
i | 执行对大小写不敏感的匹配
g | 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）
m | 执行多行匹配

### 对象方法

方法 | 描述
--- | ---
compile | 编译正则表达式
exec | 检索字符串中指定的值。返回找到的值，并确定其位置
test | 检索字符串中指定的值。返回 true 或 false

## 示例

```javascript
//这是一个用来匹配URL的正则表达式，分组获取不同部分的信息
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
var url = "http://www.ora.com:80/goodparts?q#fragment";
var result = parse_url.exec(url);
var names = ["url", "scheme", "slash", "host", "port", "path", "query", "hash"];var i;
for (i = 0; i < names.length; i++) {
    document.writeln(names[i] + ": " + result[i] + "<br/>");
}

//这段代码的输出结果如下：
url: http://www.ora.com:80/goodparts?q#fragment
scheme: http
slash: //
host: www.ora.com
port: 80
path: goodparts
query: q
hash: fragment
```

下面让我们分解parse_url的各个部分，看看它是如何工作的：

`^`：^字符表示此字符串的开始，它是一个锚，指引exec不要跳过那些不像URL的前缀，只匹配那些从开头就像URL一样的字符串。

`(?:([A-Za-z]+):)?`：这个因子匹配一个协议名，但仅当它后面跟随一个 :（冒号）的时候才匹配。(?: . . .)表示一个非捕获型分组（noncapturing group）。后缀 ? 表示这个分组是可选的，它表示重复0次或1次。( . . .)表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并把其放到result数组里。每个捕获型分组都会被指定一个编号。第一个捕获型分组的编号是1，所以该分组所匹配的文本副本会出现在result[1]中。 [ . . .]表示一个字符类。A-Za-z这个字符类包含26个大写字母和26个小写字母。连接字符 - 表示范围从A-Z。后缀 + 表示这个字符类会被匹配一次或多次。这个组后面跟着字符 : ，它会按字面进行匹配。

`(\/{0,3})`：这个因子是捕获型分组2，匹配//。\ /表示应,该匹配 / （斜杠）。它用 \ （反斜杠）来进行转义，这样它就不会被错误地解释为这个正则表达式的结束符。后缀 {0,3} 表示 / 会匹配0~3次。

`([0-9.\-A-Za-z]+)`：这个因子是捕获型分组3。它会匹配一个主机名，由一个或多个数字、字母以及 . 或 - 字符组成。- 会被转义为 \- 以防止与表示范围的连字符相混淆。

`(?::(\d+))?`：这个可选的因子匹配端口号，它是由一个前置 : 加上一个或多个数字而组成的序列。\d表示一个数字字符。一个或多个数字组成的数字串会被捕获型分组4捕获。

`(?:\/([^?#]*))?`：这个因子也是可选的分组，匹配路径。该分组以一个 / 开始。之后的字符类[^?#]以一个^开始，它表示这个类包含除 ? 和 # 之外的所有字符。* 表示这个字符类会被匹配0次或多次。

**注意：** 我在这里的处理是不严谨的。这个类匹配除 ? 和 # 之外的所有字符，其中包括了行结束符、控制字符、以及其他大量不应在此被匹配的字符。大多数情况下，它会按照我们的预期去做，但某些恶意文本可能会有渗漏进来的风险。不严谨的正则表示式是一个常见的安全漏洞发源地。写不严谨的正则表达式比写严谨的正则表示式要容易的多。

`(?:\?([^#]*))?`：这个因子是一个以一个 ? 开始的可选分组。它包含捕获型分组6，这个分组包含0个或多个非#字符。

`(?:#(.*))?`：这个因子是以 # 开始的可选分组。. 会匹配除行结束符以外的所有字符。

`$`：$表示这个字符串的结束。它保证在这个URL的尾部没有其他更多的内容了。

## 参考资料

- 《JavaScript语言精粹》

- [http://www.runoob.com/regexp/regexp-tutorial.html](http://www.runoob.com/regexp/regexp-tutorial.html)